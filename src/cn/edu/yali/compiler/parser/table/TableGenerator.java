package cn.edu.yali.compiler.parser.table;

import cn.edu.yali.compiler.lexer.TokenKind;
import cn.edu.yali.compiler.utils.FileUtils;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Construct LR analysis table according to the grammar file.
 * <br>
 * This file is a non-essential framework file, used to improve the uniformity of the entire compiler processing flow and provide students with a reference for the SLR(1) analysis table generation program. 
 */
public class TableGenerator {
    public TableGenerator() {
        this.productions = GrammarInfo.getProductionsInOrder();
        this.terminals = new HashSet<>(TokenKind.allAllowedTokenKinds().values());
        this.nonTerminals = new HashSet<>(GrammarInfo.getNonTerminals().values());

        if (productions.get(0).body().size() != 1) {
            throw new RuntimeException("The first production in grammar file must like S -> S'");
        }
    }

    /**
     * Main method
     */
    public void run() {
        calcFirst();
        calcFollow();
        constructDFA();
        dumpItems();
        genTable();
    }

    /**
     * Print the LR(0) canonical set generated by the analysis table to a file for debugging
     */
    public void dumpItems() {
        final var lines = new ArrayList<String>();
        for (final var status : allStatusInIndexOrder) {
            lines.add("%d: ".formatted(status.index()));
            for (final var item : including.get(status)) {
                lines.add("    " + item);
            }
        }

        FileUtils.writeLines("data/out/items.txt", lines);
    }

    /**
     * @return The constructed LR table
     */
    public LRTable getTable() {
        return new LRTable(allStatusInIndexOrder, new ArrayList<>(terminals), new ArrayList<>(nonTerminals));
    }

    private final List<Production> productions;
    private final Set<TokenKind> terminals;
    private final Set<NonTerminal> nonTerminals;

    private final Map<Term, Set<TokenKind>> first = new HashMap<>();
    private final Map<Term, Set<TokenKind>> follow = new HashMap<>();

    private final Set<Term> visited = new HashSet<>();

    /**
     * Calculate the first set of all symbols <br>
     * The first of a terminal symbol is itself, and the first of a non-terminal symbol is calculated recursively
     */
    private void calcFirst() {
        for (final var terminal : terminals) {
            first.put(terminal, Set.of(terminal));
        }

        for (final var nonTerminal : nonTerminals) {
            visited.clear();
            calcFirst(nonTerminal);
        }

    }

    /**
     * Recursively calculate the first of a specific non-terminal symbol
     *
     * @param nonTerminal Non-terminal symbol
     * @return Its first collection
     */
    private Set<TokenKind> calcFirst(Term nonTerminal) {
        // If it has been calculated, the cached result is returned directly
        if (first.containsKey(nonTerminal)) {
            return first.get(nonTerminal);
        }

        final var result = new LinkedHashSet<TokenKind>();
        for (final var production : productions) {
            if (nonTerminal == production.head()) {
                // Find a production in the grammar that starts with this non-terminal symbol
                final var firstSymbol = production.body().get(0);
                // Record the recursive non-terminal symbols that have been in the stack to prevent direct or indirect left recursion from causing program dead loops
                if (!visited.contains(firstSymbol)) {
                    // Then recursively search the first set of the first grammar symbol of the production body
                    // Its first set is also the first set of the nonterminal symbol
                    visited.add(firstSymbol);
                    result.addAll(calcFirst(firstSymbol));
                }
            }
        }

        first.put(nonTerminal, result);
        return result;
    }


    /**
     * Compute the follow sets of all non-terminal symbols
     */
    private void calcFollow() {
        for (final var nonTerminal : nonTerminals) {
            visited.clear();
            calcFollow(nonTerminal);
        }

        // For a non-terminal symbol that has no follow after finding all productions
        // It must be an unused non-terminal symbol, which means its follow is EOF
        nonTerminals.stream()
            .map(follow::get).filter(Set::isEmpty)
            .forEach(set -> set.add(TokenKind.eof()));
    }

    /**
     * Recursively compute the follow set for a given non-terminal symbol
     *
     * @param nonTerminal The given non-terminal
     * @return Its follow set
     */
    private Set<TokenKind> calcFollow(NonTerminal nonTerminal) {
        // Similar to first, search the cache first
        if (follow.containsKey(nonTerminal)) {
            return follow.get(nonTerminal);
        }

        final var result = new LinkedHashSet<TokenKind>();
        for (final var production : productions) {
            final var body = production.body();

            // For each possible occurrence of the non-terminal in each production body, we add the first of the item following the occurrence to its follow set
            // We directly enumerate each item in each production body
            for (int i = 0; i < body.size() - 1; i++) {
                // If the current curr is found, the first of the symbol following it is its follow
                final var symbol = body.get(i);
                final var next = body.get(i + 1);

                if (symbol.equals(nonTerminal)) {
                    result.addAll(first.get(next));
                }
            }

            // If the non-terminal symbol appears at the end of the production, the follow set of the head of the production should also be added to its follow set
            final var lastInBody = body.get(body.size() - 1);
            if (lastInBody.equals(nonTerminal)) {
                final var head = production.head();
                if (visited.contains(head)) {
                    // If the production head is already in the stack, it means that this non-terminal symbol may continue to expand itself
                    // At this time, EOF may also be its Follow
                    result.add(TokenKind.eof());
                } else {
                    // Otherwise, search recursively
                    visited.add(head);
                    result.addAll(calcFollow(head));
                }
            }
        }

        follow.put(nonTerminal, result);
        return result;
    }

    /**
     * represents a project
     * <br>
     * For A -> B . C, its production is A -> B C, dot is 1 (the index of its next item C) <br>
     * For A -> B C ., its production is A -> B C, dot is 2 (the number of items in its production body) <br>
     *
     * @param production Production
     * @param dot        The currently parsed position
     */
    private record Item(Production production, int dot) {
        /**
         * @return Is the point at the end of the production?
         */
        public boolean isDotAtEnd() {
            return production.body().size() == dot;
        }

        /**
         * @return Get the grammar symbol after the dot; if the point is at the end, return empty
         */
        public Optional<Term> getAfterDot() {
            if (isDotAtEnd()) {
                return Optional.empty();
            } else {
                return Optional.of(production.body().get(dot));
            }
        }

        /**
         * @return Get the successor item of the current item; return null if the point is at the end
         */
        public Optional<Item> getNextItem() {
            if (isDotAtEnd()) {
                return Optional.empty();
            } else {
                return Optional.of(new Item(production, dot + 1));
            }
        }

        @Override
        public String toString() {
            final var builder = new StringBuilder();

            builder.append(production.head());
            builder.append(" -> ");

            final var body = production.body();
            for (int i = 0; i < body.size(); i++) {
                if (i == dot) {
                    builder.append(" .");
                }
                builder.append(" ").append(body.get(i));
            }

            if (dot == body.size()) {
                builder.append(" .");
            }

            return builder.toString();
        }
    }

    private final Map<Set<Item>, Status> belongTo = new HashMap<>();
    private final Map<Status, Set<Item>> including = new HashMap<>();
    private final List<Status> allStatusInIndexOrder = new ArrayList<>();

    /**
     * Construct all states and maintain the correspondence between states and item sets
     */
    private void constructDFA() {
        final var argumentProduction = productions.get(0);
        final var initItem = new Item(argumentProduction, 0);
        final var collections = constructCanonicalLRCollection(initItem);

        for (int idx = 0; idx < collections.size(); idx++) {
            final var status = Status.create(idx);
            allStatusInIndexOrder.add(status);

            final var items = collections.get(idx);
            including.put(status, items);
            belongTo.put(items, status);
        }
    }

    /**
     * @param head Head symbol
     * @return Returns a stream whose elements are all productions starting with head.
     */
    private Stream<Production> getProductionsByHead(Term head) {
        return productions.stream().filter(production -> production.head().equals(head));
    }

    /**
     * Constructs the closure of the item set {@code sourceItem}, which is equivalent to the CLOSURE(I) function in the theory class
     *
     * @param sourceItem Itemset I
     * @return Closures
     */
    private Set<Item> constructClosure(Set<Item> sourceItem) {
        // Use the BFS method to avoid detecting changes to the collection every time
        final var result = new LinkedHashSet<>(sourceItem);
        // Items that have been found, but whose expansions have not yet been fully explored
        // Similar to the queue of BFS or the gray list in the mark-and-sweep GC algorithm
        final var unexpanded = new ArrayDeque<>(sourceItem);

        while (!unexpanded.isEmpty()) {
            final var top = unexpanded.pollFirst();
            // Get the symbol after the midpoint of the current item
            top.getAfterDot().ifPresent(afterDot ->
                // Then search for productions with this symbol as the head
                getProductionsByHead(afterDot)
                    // The construction point is at the beginning of the corresponding production
                    .map(production -> new Item(production, 0))
                    // For new items not in result
                    .filter(item -> !result.contains(item))
                    // Join the queue and add to the results
                    .peek(unexpanded::add)
                    .forEach(result::add));
        }

        return result;
    }

    /**
     * Equivalent to the GO(I, X) function (transfer function) in the theory class
     *
     * @param items current item set I
     * @param term grammar symbol X
     * @return I subsequent item set about X
     */
    private Set<Item> constructGoto(Set<Item> items, Term term) {
        final var kernelForGoto = items.stream()
            // First filter out all items in I that are followed by term
            .filter(item -> item.getAfterDot().map(term::equals).orElse(false))
            // Then find the successor of each term separately
            // This itemset is the core of the successor itemset
            .map(Item::getNextItem).flatMap(Optional::stream)
            .collect(Collectors.toSet());

        // Then construct the closure from the core of the successor itemset to get the successor itemset
        return constructClosure(kernelForGoto);
    }

    /**
     * Construct LR(0) canonical item set family
     *
     * @param initItem starting item S -> . S'
     * @return canonical item set family
     */
    private List<Set<Item>> constructCanonicalLRCollection(Item initItem) {
        // First collect all the grammar symbols for later use
        final var terms = new LinkedHashSet<Term>();
        terms.addAll(nonTerminals);
        terms.addAll(terminals);

        // Constructing the initial project set family
        final var initClosure = constructClosure(Set.of(initItem));

        // Also search in BFS format
        final var result = new LinkedHashSet<>(Set.of(initClosure));
        final var unexpanded = new ArrayDeque<>(Set.of(initClosure));

        while (!unexpanded.isEmpty()) {
            final var items = unexpanded.pollFirst();

            // For each unexplored set
            for (final var term : terms) {
                // Try to find a successor item set for each grammar symbol
                final var to = constructGoto(items, term);
                // If it has not been added to the result
                if (!to.isEmpty() && !result.contains(to)) {
                    // Add it to the result and to-be-explored list
                    result.add(to);
                    unexpanded.addLast(to);
                }
            }
        }

        return new ArrayList<>(result);
    }

    /**
     * Construct LR analysis table (fill in action and goto in each status)
     */
    private void genTable() {
        // For each item in each state in index order
        for (final var status : allStatusInIndexOrder) {
            for (final var item : including.get(status)) {
                final var afterDotOpt = item.getAfterDot();

                // Classify items based on the position of the dot and the grammar symbol following the dot
                if (afterDotOpt.isEmpty()) {
                    final var argumentProduction = productions.get(0);
                    if (item.production().equals(argumentProduction)) {
                        // S -> S' .
                        // If the item represents the end of the starting grammar, then if EOF is encountered again, it is accepted.
                        status.setAction(TokenKind.eof(), Action.accept());
                    } else {
                        // A -> alpha .
                        // If the item represents the end of a production, then any grammar symbol in follow(A) should be reduced to A.
                        final var production = item.production();
                        final var head = production.head();
                        for (final var a : follow.get(head)) {
                            status.setAction(a, Action.reduce(production));
                        }
                    }

                } else {
                    final var symbol = afterDotOpt.get();
                    final var next = belongTo.get(constructGoto(including.get(status), symbol));

                    if (symbol instanceof TokenKind tokenKind) {
                        // A -> alpha . a beta
                        // If the item represents the middle of a production and is followed by a terminal, we move in the terminal.
                        status.setAction(tokenKind, Action.shift(next));
                    } else if (symbol instanceof NonTerminal nonTerminal) {
                        // A -> alpha . B beta
                        // If the item represents the middle of a production and is followed by a nonterminal,
                        // We will move to the state after B is parsed (that is, the state corresponding to GO(I, B))
                        status.setGoto(nonTerminal, next);
                    } else {
                        throw new RuntimeException("Unknown type of Term");
                    }
                }
            }
        }
    }

    // We check for specification-specification conflicts and move-specification conflicts in Status.setAction/setGoto
    // If there is a conflict, they will throw RuntimeException
}
