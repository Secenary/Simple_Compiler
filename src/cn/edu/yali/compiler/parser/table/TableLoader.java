package cn.edu.yali.compiler.parser.table;

import cn.edu.yali.compiler.lexer.TokenKind;
import cn.edu.yali.compiler.utils.FileUtils;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Reads the parsing table generated by the Compile Workbench and converts it to an LRTable structure
 */
public class TableLoader {
    /**
     * Read analysis table
     *
     * @param path Analysis table path in CSV format
     * @return LRTable
     */
    public LRTable load(String path) {
        final var csv = FileUtils.readCSV(path);
        // The table header is the line with Status, ACTION, ..., GOTO, ...
        final var tableHeader = csv.get(0);

        // Determine the column numbers of each part based on the row
        final var statusColumnIndex = 0;
        final var actionColumnBegin = 1;
        final var actionColumnEnd = tableHeader.indexOf("GOTO");
        final var gotoColumnBegin = actionColumnEnd;
        final var gotoColumnEnd = tableHeader.size();

        // The symbol line is where the terminal and non-terminal symbols are stored.
        final var symbolHeader = csv.get(1);
        final var terminals = symbolHeader
            .subList(actionColumnBegin, actionColumnEnd).stream()
            .map(TokenKind::fromString).toList();
        final var nonTerminals = symbolHeader
            .subList(gotoColumnBegin, gotoColumnEnd).stream()
            .map(NonTerminal::new).toList();

        // Below is the main body of the table
        final var statusRows = csv.subList(2, csv.size());

        // First read all status numbers and construct the corresponding Status objects
        for (final var row : statusRows) {
            final var statusIndexString = row.get(statusColumnIndex);
            final var statusIndex = Integer.parseInt(statusIndexString);
            final var status = Status.create(statusIndex);

            statusInIndexOrder.add(status);
            statuses.put(statusIndex, status);
        }

        // Then read the ACTION and GOTO tables to fill the action and goto information for the constructed Status object
        for (final var row : statusRows) {
            final var status = statuses.get(Integer.valueOf(row.get(statusColumnIndex)));

            // Processing the ACTION table
            for (int idx = actionColumnBegin; idx < actionColumnEnd; idx++) {
                final var relativeIndex = idx - actionColumnBegin;
                final var terminal = terminals.get(relativeIndex);

                final var action = parseAction(row.get(idx));
                status.setAction(terminal, action);
            }

            // Processing the GOTO Table
            for (int idx = gotoColumnBegin; idx < gotoColumnEnd; idx++) {
                final var relativeIndex = idx - gotoColumnBegin;
                final var nonTerminal = nonTerminals.get(relativeIndex);

                final var goto_ = parseGoto(row.get(idx));
                status.setGoto(nonTerminal, goto_);
            }
        }

        // Return the constructed LR table
        return new LRTable(statusInIndexOrder, terminals, nonTerminals);
    }

    private final List<Status> statusInIndexOrder = new ArrayList<>();
    private final Map<Integer, Status> statuses = new HashMap<>();

    /**
     * Parse the string of the ACTION table
     *
     * @param text The text of the corresponding cell
     * @return The parsed action
     */
    private Action parseAction(String text) {
        // Empty string represents error action
        if (text.isEmpty()) {
            return Action.error();
        }

        // Actions are always divided into two parts: "<command> <payload>", separated by spaces
        // limit is <, limit = 2 means the number of cuts can only be < 2, that is, cut once.
        // It is possible that the length of words is only 1, in this case text is accept
        final var words = text.split(" ", 2);
        final var command = words[0];

        return switch (command) {
            case "shift" -> {
                final var statusIndex = Integer.valueOf(words[1]);
                final var status = statuses.get(statusIndex);
                yield Action.shift(status);
            }

            case "reduce" -> {
                final var production = GrammarInfo.getProductionByText(words[1]);
                yield Action.reduce(production);
            }

            case "accept" -> Action.accept();

            default -> throw new RuntimeException("Illegal action in table: " + text);
        };
    }

    /**
     * Parse the string in the GOTO table
     *
     * @param text The text of the corresponding cell
     * @return The parsed status
     */
    private Status parseGoto(String text) {
        if (text.isEmpty()) {
            return Status.error();
        } else {
            return statuses.get(Integer.valueOf(text));
        }
    }
}
