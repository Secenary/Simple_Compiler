package cn.edu.yali.compiler.asm;

import cn.edu.yali.compiler.ir.IRImmediate;
import cn.edu.yali.compiler.ir.IRVariable;
import cn.edu.yali.compiler.ir.Instruction;
import cn.edu.yali.compiler.parser.table.BMap;
import cn.edu.yali.compiler.utils.FileUtils;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;


/**
 * Experiment 4: Implement assembly generation
 * <br>
 * In the overall framework of the compiler, code generation can be called the backend, and all the previous work can be called the frontend.
 * <br>
 * All the work done by the frontend is independent of the target platform, and the work of the backend is to convert the target platform-independent information generated by the frontend
 * into assembly code according to the target platform. The separation of the frontend and the backend is conducive to the compiler generating assembly code for different platforms. Due to the separation of the frontend and the backend, it is possible that the intermediate code generated by the frontend does not conform to the assembly code characteristics of the target platform. Specifically for this project, you can
 * try to add a method to adjust the intermediate code to a form closer to risc-v assembly, which will be conducive to the generation of assembly code.
 * <br>
 * In order to ensure the freedom of implementation, the framework does not provide infrastructure for the backend, and you can design the relevant data structure yourself in the specific implementation.
 *
 * @see AssemblyGenerator#run() Code Generation and Register Allocation
 */
public class AssemblyGenerator {
    private List<Instruction> tmpInstructions = new ArrayList<>();
    private List<String> AssemblyCode = new ArrayList<>();
    private BMap<IRVariable, String> Allocreg = new BMap<>();
    private IRVariable DollarVariable = IRVariable.temp();
    private boolean IsOcuupied = false;
    private LinkedHashSet<Integer> numbers = new LinkedHashSet<Integer>();

    /**
     * Load the intermediate code provided by the front end
     * <br>
     * Depending on the specific implementation, some information used in code generation will be generated during or after loading. Such as variable reference
     * information. This information can be maintained through simple mapping, or the data structure for recording information can be added by yourself.
     *
     * @param originInstructions The intermediate code provided by the front end
     */
    public void loadIR(List<Instruction> originInstructions) {
        // Read the intermediate code provided by the front end and generate the required information
        tmpInstructions = originInstructions;
        for (int i = 0; i < tmpInstructions.size(); i++) {
            Instruction tmpInstruction = tmpInstructions.get(i);

            if (tmpInstruction.getKind().toString().equals("ADD")) {
                String tmp1 = tmpInstruction.getLHS().toString();
                String tmp2 = tmpInstruction.getRHS().toString();
                boolean flag1 = true, flag2 = true;
                for (int j = 0; j < tmp1.length(); j++) {
                    char ch = tmp1.charAt(j);
                    if(!Character.isDigit(ch)) flag1 = false;
                }
                for (int j = 0; j < tmp2.length(); j++) {
                    char ch = tmp2.charAt(j);
                    if(!Character.isDigit(ch)) flag2 = false;
                }
                if (flag1 && flag2) {
                    int cal_result = Integer.parseInt(tmp1) + Integer.parseInt(tmp2);
                    tmpInstructions.set(i, Instruction.createMov(tmpInstruction.getResult(), IRImmediate.of(cal_result)));
                }
                else if (flag1) {
                    tmpInstructions.set(i, Instruction.createAdd(tmpInstruction.getResult(), tmpInstruction.getRHS(), tmpInstruction.getLHS()));
                }
            }

            else if (tmpInstruction.getKind().toString().equals("SUB")) {
                String tmp1 = tmpInstruction.getLHS().toString();
                String tmp2 = tmpInstruction.getRHS().toString();
                boolean flag1 = true, flag2 = true;
                for (int j = 0; j < tmp1.length(); j++) {
                    char ch = tmp1.charAt(j);
                    if(!Character.isDigit(ch)) flag1 = false;
                }
                for (int j = 0; j < tmp2.length(); j++) {
                    char ch = tmp2.charAt(j);
                    if(!Character.isDigit(ch)) flag2 = false;
                }
                if (flag1 && flag2) {
                    int cal_result = Integer.parseInt(tmp1) - Integer.parseInt(tmp2);
                    tmpInstructions.set(i, Instruction.createMov(tmpInstruction.getResult(), IRImmediate.of(cal_result)));
                }
                else if (flag1) {
                    tmpInstructions.set(i, Instruction.createMov(DollarVariable, tmpInstruction.getLHS()));
                    tmpInstructions.add(i + 1, Instruction.createSub(tmpInstruction.getResult(), DollarVariable, tmpInstruction.getRHS()));
                }
            }

            else if (tmpInstruction.getKind().toString().equals("MUL")) {
                String tmp1 = tmpInstruction.getLHS().toString();
                String tmp2 = tmpInstruction.getRHS().toString();
                boolean flag1 = true, flag2 = true;
                for (int j = 0; j < tmp1.length(); j++) {
                    char ch = tmp1.charAt(j);
                    if(!Character.isDigit(ch)) flag1 = false;
                }
                for (int j = 0; j < tmp2.length(); j++) {
                    char ch = tmp2.charAt(j);
                    if(!Character.isDigit(ch)) flag2 = false;
                }
                if (flag1 && flag2) {
                    int cal_result = Integer.parseInt(tmp1) + Integer.parseInt(tmp2);
                    tmpInstructions.set(i, Instruction.createMov(tmpInstruction.getResult(), IRImmediate.of(cal_result)));
                }
                else if (flag1) {
                    tmpInstructions.set(i, Instruction.createMov(DollarVariable, tmpInstruction.getLHS()));
                    tmpInstructions.add(i + 1, Instruction.createMul(tmpInstruction.getResult(), DollarVariable, tmpInstruction.getRHS()));
                }
                else if (flag2) {
                    tmpInstructions.set(i, Instruction.createMov(DollarVariable, tmpInstruction.getRHS()));
                    tmpInstructions.add(i + 1, Instruction.createMul(tmpInstruction.getResult(), DollarVariable, tmpInstruction.getLHS()));
                }
            }

            else if (tmpInstruction.getKind().toString().equals("RET")) {
                if(i + 1 < tmpInstructions.size()) {
                    for(int j = i + 1; j < tmpInstructions.size(); j++) tmpInstructions.remove(j);
                }
            }

        }
        AssemblyCode.add(".text");
    }


    /**
     * Execute code generation.
     * <br>
     * According to the practice in the theoretical class, register allocation is completed at the same time as code generation. If you think this is not a good practice,
     * you can also separate register allocation and code generation.
     * <br>
     * Tips: Register allocation requires a lot of information. It is recommended to complete the establishment of global information that is not related to the code generation process before code generation. Information related to the code generation process can be recorded and dynamically maintained by designing a data structure.
     */
    public void run() {
        // Perform register allocation and code generation
        int cnt = 0;
        for (int i = 0; i < tmpInstructions.size(); i++) {
            var perInstruction = tmpInstructions.get(i);
            if (perInstruction.getKind().toString().equals("ADD") || perInstruction.getKind().toString().equals("SUB") || perInstruction.getKind().toString().equals("MUL")) {

                if (cnt == 7) {
                    IsOcuupied = true;
                    cnt = 0;
                }

                if (IsOcuupied) {
                    for (int j = i; j < tmpInstructions.size(); j++) {
                        if (tmpInstructions.get(j).getKind().toString().equals("ADD") || tmpInstructions.get(j).getKind().toString().equals("SUB") || tmpInstructions.get(j).getKind().toString().equals("MUL")) {
                            if (Allocreg.containsKey(tmpInstructions.get(j).getResult()))
                                numbers.add(Integer.valueOf(Allocreg.getByKey(tmpInstructions.get(j).getResult()).substring(1)));

                            if (Allocreg.containsKey((IRVariable) tmpInstructions.get(j).getLHS()))
                                numbers.add(Integer.valueOf(Allocreg.getByKey((IRVariable) tmpInstructions.get(j).getLHS()).substring(1)));

                            boolean flag3 = true;
                            for (int k = 0; k < perInstruction.getRHS().toString().length(); k++) {
                                char ch = perInstruction.getRHS().toString().charAt(k);
                                if(!Character.isDigit(ch)) flag3 = false;
                            }
                            if (!flag3 && Allocreg.containsKey((IRVariable) tmpInstructions.get(j).getRHS()))
                                numbers.add(Integer.valueOf(Allocreg.getByKey((IRVariable) tmpInstructions.get(j).getRHS()).substring(1)));

                        }
                    }

                    boolean flag4 = false;
                    for (int j = 0; j <= 6; j++) {
                        if (!numbers.contains(j)) {
                            StringBuilder t = new StringBuilder("t");
                            t.append(j);
                            String t_registers = t.toString();
                            numbers.add(j);
                            if(!Allocreg.containsKey(perInstruction.getResult())) {
                                Allocreg.replace(perInstruction.getResult(), t_registers);
                            }
                            flag4 = true;
                            break;
                        }
                    }

                    if (flag4) {
                        if (perInstruction.getKind().toString().equals("ADD")) {
                            AssemblyCode.add("    add " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getRHS()));
                        }
                        if (perInstruction.getKind().toString().equals("SUB")) {
                            AssemblyCode.add("    sub " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getRHS()));
                        }
                        if (perInstruction.getKind().toString().equals("MUL")) {
                            AssemblyCode.add("    mul " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getRHS()));
                        }
                    }

                    else throw new RuntimeException("No Registers Available");

                    continue;
                }

                if (!Allocreg.containsKey(perInstruction.getResult())) {
                    StringBuilder t = new StringBuilder("t");
                    t.append(cnt);
                    String t_registers = t.toString();
                    Allocreg.replace(perInstruction.getResult(), t_registers);
                    ++cnt;
                }

                if (!Allocreg.containsKey((IRVariable) perInstruction.getLHS())) {
                    StringBuilder t = new StringBuilder("t");
                    t.append(cnt);
                    String t_registers = t.toString();
                    Allocreg.replace((IRVariable) perInstruction.getLHS(), t_registers);
                    ++cnt;
                }

                boolean flag2 = true;
                for (int j = 0; j < perInstruction.getRHS().toString().length(); j++) {
                    char ch = perInstruction.getRHS().toString().charAt(j);
                    if(!Character.isDigit(ch)) flag2 = false;
                }
                if (!flag2 && !Allocreg.containsKey((IRVariable) perInstruction.getRHS())) {
                    StringBuilder t = new StringBuilder("t");
                    t.append(cnt);
                    String t_registers = t.toString();
                    Allocreg.replace((IRVariable) perInstruction.getRHS(), t_registers);
                    ++cnt;
                }

                if (perInstruction.getKind().toString().equals("ADD")) {
                    boolean flag = true;
                    for(int j = 0; j < perInstruction.getRHS().toString().length(); j++) {
                        char ch = perInstruction.getRHS().toString().charAt(j);
                        if(!Character.isDigit(ch)) flag = false;
                    }
                    if (flag)
                        AssemblyCode.add("    addi " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS()) + ", " + perInstruction.getRHS());
                    else
                        AssemblyCode.add("    add " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getRHS()));
                }
                else if (perInstruction.getKind().toString().equals("SUB"))
                    AssemblyCode.add("    sub " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS())  + ", " + Allocreg.getByKey((IRVariable) perInstruction.getRHS()));
                else if (perInstruction.getKind().toString().equals("MUL"))
                    AssemblyCode.add("    mul " + Allocreg.getByKey(perInstruction.getResult()) + ", " + Allocreg.getByKey((IRVariable) perInstruction.getLHS())  + ", " + Allocreg.getByKey((IRVariable) perInstruction.getRHS()));
            }

            if (perInstruction.getKind().toString().equals("MOV")) {
                if (!Allocreg.containsKey(perInstruction.getResult())) {

                    boolean flag = true;
                    for (int j = 0; j < perInstruction.getFrom().toString().length(); j++) {
                        char ch = perInstruction.getFrom().toString().charAt(j);
                        if(!Character.isDigit(ch)) flag = false;
                    }
                    if (flag) {
                        StringBuilder t = new StringBuilder("t");
                        t.append(cnt);
                        String t_registers = t.toString();
                        Allocreg.replace(perInstruction.getResult(), t_registers);
                        AssemblyCode.add("    li " + t_registers + ", " + perInstruction.getFrom());
                    }
                    else {
                        StringBuilder t = new StringBuilder("t");
                        t.append(cnt);
                        String t_registers = t.toString();
                        Allocreg.replace(perInstruction.getResult(), t_registers);
                        AssemblyCode.add("    mv " + t_registers + ", " + Allocreg.getByKey((IRVariable) perInstruction.getFrom()));
                    }
                    ++cnt;
                }
            }

            if (perInstruction.getKind().toString().equals("RET"))
                AssemblyCode.add("    mv a0, " + Allocreg.getByKey((IRVariable) perInstruction.getReturnValue()));
        }

    }


    /**
     * Dump assembly code to a file
     *
     * @param path Dump file path
     */
    public void dump(String path) {
        // Dump assembly code to a file
        FileUtils.writeLines(path, AssemblyCode.stream().toList());
    }
}